# array-crypto

Кратко: небольшой экспериментальный проект для динамической генерации «snapshot» (tick, seed, timestamp) на сервере и использования этого состояния на клиенте для простого симметричного шифрования потоков.

Состав:
- server.py — FastAPI-сервер, выдаёт snapshot и принимает упрощённый handshake (регистрация 16-байтового хэша).
- client.py — клиент на asyncio/aiohttp, выполняет handshake, получает snapshot, выводит пример шифрования/дешифрования сообщения.

Ключевая логика:
- Сервер поддерживает счётчик tick и случайный seed; snapshot подписывается HMAC-SHA256 и кодируется Base64.
- Клиент генерирует функцию (набор точек), хэширует её и отправляет в /handshake; затем запрашивает /snapshot, проверяет подпись и использует seed+tick+salt для детерминированной генерации ключа (массив байтов) и простого поблочного умножения для шифрования.

Endpoints:
- POST /handshake — body: {"hash": "<hex16>"} — регистрирует короткий клиентский хэш.
- GET /snapshot — возвращает {tick, seed, timestamp, signature} (signature — HMAC over "tick|seed|timestamp").

Как запускать (локально):
1) Установить зависимости: pip install -r requirements.txt
2) Запустить сервер: python server.py
3) Запустить клиент: python client.py

Ограничения и замечания безопасности:
- Это экспериментальный код. HMAC secret и handshake-хранимые значения захардкожены и небезопасны для продакшна.
- Метод шифрования использует простое умножение байтов по модулю 256 и не обеспечивает криптографическую устойчивость.
- Нет защиты от повторного воспроизведения, отсутствует полноценное управление сессиями и механизмы обновления ключей.

Файлы для просмотра:
- server.py — логика API и подписи snapshot.
- client.py — генерация handshake, верификация подписи, ключеобразование, шифрование/дешифрование.

Лицензия: см. LICENSE (в корне репозитория).